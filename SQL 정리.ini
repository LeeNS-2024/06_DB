                        SQL 정리

** 01_SELECT (조회) **
 
 - 지정된 테이블에서 원하는 데이터가 존재하는 행을
   선택해서 조회하는 SQL(구조적 질의 언어)
 
 - 작성된 구문에 맞는 행, 열 데이터가 조회됨
   -> 조회 결과 행의 집합 == RESULT SET  (중요!!)
 
 - 조회 결과는 0행 이상 (조건에 맞는 행이 없을 수 있다!)

 [SELECT 작성법 - 1]
 
 2) SELECT 컬럼명, 컬럼명, ....
 1) FROM 테이블명;


- 지정된 테이블의 모든 행에서
  특정 컬럼만 조회하기
 
 컬럼 값 산술 연산 */

 컬럼 값 : 행과 열이 교차되는 한 칸에 작성된 값
 

 - SELECT문 작성 시
   컬럼명에 산술 연산을 작성하면
   조회 결과(RESULT SET)에서
   모든 행에 산술 연산이 적용된 결과 값이 조회된다!!


*  SYSDATE/CURRENT_DATE , SYSTIMESTAMP/CURRENT_TIMESTAMP
 DB는 날짜/시간 관련 데이터를 다루기 굉장히 편하다!!!

 - SYSDATE : 시스템이 나타내고 있는 현재 시간
 - CURRENT_DATE : 현재 세션(사용자 기반) 시간
 
 - SYSTIMESTAMP : 시스템이 나타내고 있는 현재 시간
 		              ms 단위 + 지역 포함
 - CURRENT_TIMESTAMP : 현재 세션(사용자 기반) 시간
 		              ms 단위 + 지역 포함


* DUAL (DUmmy tAbLe)
 - 가짜 테이블(임시 테이블)
 - 조회하려는 데이터가 실제 테이블에 존재하는 데이터가 아닌 경우에 사용



* 날짜 데이터 연산하기 ( + , - 만 가능!!!)

 날짜 + 1  == 1일 증가
 날짜 - 1  == 1일 감소
 > 정수 연산은 일 단위로 연산된다!!


* 현재 시간, 한 시간 후, 1분 후, 10초 후 조회
SELECT 
	CURRENT_DATE,
	CURRENT_DATE + 1/24,
	CURRENT_DATE + 1/24/60,
	CURRENT_DATE + 1/24/60/60 * 10

 날짜 끼리 연산하기 ( - 만 가능!! )
 > 연산 결과는 일 단위 ( 1 == 1일 )

 TO_DATE('날짜문자열', '패턴');
  -> '날짜문자열'을 '패턴' 형식으로 해석하여 
      DATE 타입으로 변환하는 함수
ex) TO_DATE('2024-08-14', 'YYYY-MM-DD')


* CEIL(숫자) : 소수점 올림 처리


* 컬럼명 별칭 지정하기

 - 별칭 지정 방법
 1) 컬럼명 AS 별칭   : 문자 O, 띄어쓰기 X, 특수문자 X
 
 2) 컬럼명 AS "별칭" : 문자 O, 띄어쓰기 O, 특수문자 O
 
   -> AS는 생략 가능!!
 
 - ORACLE 에서 ""의 의미
  -> "" 내부에 작성된 글자 그대로를 인식해라!!!
    EX)  -  : 빼기
        "-" : - 모양의 글자
    
 ORACLE에서 문자열은 '' (홑따옴표)



* 연결 연산자 (||) 
- 두 컬럼을 이어서 하나의 컬럼으로 조회할 때 사용

* SELECT절에 컬럼명이 아닌 리터럴(값) 작성하는 경우 
 - 조회 결과에 작성된 리터럴 컬럼이 추가되고, 
   모든 행에 리터럴이 작성되어 있음


* DISTINCT(별개의, 전혀 다른) 
 - 조회 결과 집합(RESULT SET)에서
   DISTINCT가 지정된 컬럼 중 중복되는 값이 존재할 경우
   중복을 제거하고 한 번만 표시할 때 사용하는 구문(연산자)



* WHERE절
-- 테이블에서 조건을 충족하는 행을 조회할 때 사용
-- WHERE절에는 조건식(true/false)만 작성

-- 비교 연산자 : >, <, >=, <=, = (같다), !=, <> (같지 않다)
-- 논리 연산자 : AND, OR, NOT

 [SELECT 작성법 - 2]
 
 3) SELECT 컬럼명, ...
 1) FROM 테이블명
 2) WHERE 조건식;
 
 1>> 특정 테이블에서
 2>> 조건식을 만족하는 행을 추려놓고
 3>> 추려진 결과 행에서 원하는 컬럼만 조회


 NULL 비교 연산
 컬럼명 = NULL  ,  컬럼명 != NULL  (X)
 
  -> = , != 비교 연산은 
     컬럼에 저장된 값을 비교하는 연산이다!!!
 
  -> ORACLE DB에서 NULL은 값이 아니라
     값이 존재하지 않는다는(빈칸) 의미
      == 저장된 값이 없다
 
 ****************************************
 컬럼명 IS NULL  /  컬럼명 IS NOT NULL   (O)
   -> 지정된 컬럼에 값이 존재하지 않는 경우 / 존재하는 경우 
      (값의 유무를 따짐)


* 논리 연산자(AND/OR)

 AND(그리고) : 두 조건식의 결과가 TRUE인 경우만 TRUE
	> 두 조건을 모두 만족하는 행만 조회 결과에 포함

 OR(또는)   : 두 조건 중 하나라도 TRUE인 경우에 TRUE
	> 두 조건 중 하나라도 만족하는 행만 조회 결과에 포함


* 컬럼명 BETWEEN (A) AND (B)
  컬럼 값이 "A 이상", "B 이하"인 경우 TRUE(조회 하겠다)


* 컬럼명 NOT BETWEEN (A) AND (B)
 컬럼 값이 "A 이상", "B 이하"가 아닌 경우 TRUE(조회 하겠다)
 == A 미만, B 초과


* 컬럼명 IN(값1, 값2, 값3, ...)
 컬럼 값이 IN () 내에 존재하면 TRUE --> 조회 결과에 포함
 == 연속으로 OR 연산을 작성한 것과 같은 효과


* LIKE(같은, 비슷한)
 
 - 비교하려는 값이 특정한 패턴을 만족시키면 조회하는 연산자
 
 [작성법]
 
 WHERE 컬럼명 LIKE '패턴'
 
 - LIKE에 사용되는 패턴(와일드 카드)

 '%' (포함)
 - '%A'  : 문자열 앞부분은 어떤 문자든 포함할 수 있지만
           마지막은 A로 끝나는 문자열
 
 - 'A%'  : A로 시작하는 문자열
 
 - '%A%' : A가 포함된 문자열
 
 '_' (글자 수)
 
 - 'A___' : A로 시작하고 그 뒤에 3글자만 있는 문자열
 						EX) ABCD (O), ABCDE(X) 
 
 - '___A' : 앞에 3글자만 있고 A로 끝나는 문자열


* '_' 와일드 카드 사용 시 문제점!!!


	 - 작성되는 문자열의 '_' 기호가
	 LIKE '_' 와일드 카드와
	 똑같이 인식되서 구분이 안되는 문제가 발생!!!
	
 [해결방법]
  - LIKE 의 ESACAPE OPTION 사용
 	
 	ESACAPE OPTION : 와일드 카드가 아닌 단순 문자열로 인식
 	-> 지정된 특수문자 뒤 "한 글자"에만 적용된다!!
  
  EX)		WHERE 컬럼명 LIKE '__#_' ESCAPE '#';
   -> # 뒤에 '_'는 일반 문자열로 인식된다!


* ORDER BY 절
   SELECT 조회 결과 집합(RESULT SET)을
   원하는 순서로 정렬할 때 사용하는 구문
 
 [작성법]
 3) SELECT 컬럼명... 	(특정 컬럼만 선택해서 볼꺼야)
 1) FROM 테이블명  			(어떤 테이블에서)
 2) WHERE 조건식   			(조건을 만족하는 행만 선택(조회))
 4) ORDER BY      	(조회된 결과를 정렬할꺼야)
      컬럼명 | 별칭 | 컬럼순서(숫자)
      [ASC / DESC] (오름차순 / 내림차순)
      [NULLS FIRST / NULLS LAST] (NULL 위치 지정)

       ORDER BY절은 무조건 SECLECT 마지막에 수행된다 !!!

 오름차순(ASCENDING)  : 점점 커지는 순서
  EX) 1 -> 10 / 가 -> 하 / A -> Z / 과거 -> 미래

 내림차순(DESCENDING) : 점점 작아지는 순서


* WHERE "직급코드" IN ('J4','J5','J6') 안되는 이유 (WHERE절에서 별칭사용 안되는 이유)

  WHERE절은 SELECT절보다 먼저 해석되는데
 별칭은 SELECT절이 해석되어야 등록되기 때문에
 WHERE절에서는 별칭 사용 불가능!!

==================================

 SELECT절에 작성되지 않아도
 이전에 FROM절이 해석되어있기 때문에 정렬 가능!!!


* 정렬 기준 "중첩" 작성
 먼저 작성된 큰 그룹부터 정렬하고
 큰 그룹의 정렬이 깨지지 않는 선에서
 이후 작성된 작은 그룹을 정렬


============================================================================================


** 02.함수 **

함수 : 컬럼값 | 지정된값을 읽어 연산한 결과를 반환하는 것

 단일행 함수 : N개의 행의 컬럼 값을 전달하여 N개의 결과가 반환

 그룹 함수   : N개의 행의 컬럼 값을 전달하여 1개의 결과가 반환
               (그룹의 수가 늘어나면 그룹의 수 만큼 결과를 반환)

 함수는 SELECT절, WHERE절, ORDER BY절, GROUP BY절, HAVING절에서 사용 가능



--- 단일행 함수 ---

<문자열 관련 함수>

 LENGTH(문자열|컬럼명) : 문자열의 길이 반환

 INSTR(문자열 | 컬럼명, '찾을 문자열' [, 찾을 시작 위치 [, 순번]]) 
 : 찾을 시작 위치부터 지정된 순번째 찾은 문자열의 시작 위치를 반환

 SUBSTR(문자열 | 컬럼명, 시작위치 [,길이])
 : 문자열을 시작 위치부터 지정된 길이 만큼 잘라내서 반환
  길이 미작성 시 시작 위치 부터 끝까지 잘라내서 반환
 
 TRIM([ [옵션] 문자열 | 컬럼명 FROM ] 문자열 | 컬럼명)
 : 주어진 문자열의 앞쪽|뒤쪽|양쪽에 존재하는 지정된 문자열을 제거
  옵션 : LEADING(앞쪽), TRAILING(뒤쪽), BOTH(양쪽, 기본값)

 REPLACE(문자열 | 컬럼명, 찾을 문자열, 바꿀 문자열)
 

--- 숫자 관련 함수 ---
